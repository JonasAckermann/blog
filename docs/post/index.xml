<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on Bayesian Statistics and Functional Programming </title>
    <link>/post/</link>
    <description>Recent content in Posts on Bayesian Statistics and Functional Programming </description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Mon, 04 Nov 2019 00:00:00 +0000</lastBuildDate>
    
	<atom:link href="/post/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Analysing .fit files in R</title>
      <link>/2019/11/04/analysing-fit-files-in-r/</link>
      <pubDate>Mon, 04 Nov 2019 00:00:00 +0000</pubDate>
      
      <guid>/2019/11/04/analysing-fit-files-in-r/</guid>
      <description>Garmin running watches output a file type called .fit, the developer SDK can be downloaded from the ANT website. There is aalso Python library named fitparse which has been written to parse .fit files. This blog post will show you how to use reticulate to parse a .fit file.
Parsing reticulate::py_install(&amp;quot;fitparse&amp;quot;, method = &amp;quot;auto&amp;quot;, conda = &amp;quot;auto&amp;quot;) ## Using virtual environment &amp;#39;~/.virtualenvs/r-reticulate&amp;#39; ... The library can be imported as an R object.</description>
    </item>
    
    <item>
      <title>Bayesian Survival Analysis: Exponential Model</title>
      <link>/2019/08/09/bayesian-survival-analysis/</link>
      <pubDate>Fri, 09 Aug 2019 00:00:00 +0000</pubDate>
      
      <guid>/2019/08/09/bayesian-survival-analysis/</guid>
      <description>Poisson Distribution Consider an arbitrary interval where the expected number of events in the interval is denoted as \(\lambda\). The number of events in this interval is Poisson distributed with rate \(\lambda\). To see this, proceed to subdivide the interval into \(n\) smaller intervals \(t_1, \dots, t_n\) in which the probability of an event occurring in each small interval is \(\lambda / n\) and can be represented as an independent Bernoulli trial.</description>
    </item>
    
    <item>
      <title>Forward Mode AD in R</title>
      <link>/2019/08/05/forward-mode-automatic-differentiation-r/</link>
      <pubDate>Mon, 05 Aug 2019 00:00:00 +0000</pubDate>
      
      <guid>/2019/08/05/forward-mode-automatic-differentiation-r/</guid>
      <description>Forward Mode Automatic Differentation Automatic differentiation can be used to calculate the exact derivative of a function at a point using applications of the chain rule. Dual numbers provide a straightforward implementation in R using S3 generic methods. A dual number has a real component and a “dual” component which can be used to exacly calculate the expression and derivative at a specific value of \(x\). Consider the quadratic form \(f(x) = 5x^2 + 3x + 10\) with derivative \(f^\prime(x) = 10x + 3\).</description>
    </item>
    
    <item>
      <title>Hamiltonian Monte Carlo in R</title>
      <link>/2019/07/31/hamiltonian_monte_carlo_in_r/</link>
      <pubDate>Wed, 31 Jul 2019 00:00:00 +0000</pubDate>
      
      <guid>/2019/07/31/hamiltonian_monte_carlo_in_r/</guid>
      <description>Introduction Determining the posterior distribution for the parameters of a real-world Bayesian model inevitably requires calculating high-dimensional integrals. Often these are tedious or impossible to calculate by hand. Markov chain Monte Carlo (MCMC) algorithms are popular approaches, samplers such as the Gibbs sampler can be used to sample from models with conditionally conjugate specifications and the Metropolis-Hastings algorithm can be used when the conditionally conjugate form is not present.</description>
    </item>
    
    <item>
      <title>Bayesian Linear Regression with Gibbs Sampling in R</title>
      <link>/2019/06/14/bayesian-linear-regression-gibbs/</link>
      <pubDate>Fri, 14 Jun 2019 00:00:00 +0000</pubDate>
      
      <guid>/2019/06/14/bayesian-linear-regression-gibbs/</guid>
      <description>Linear regression models are commonly used to explain relationships between predictor variables and outcome variables. The data consists of pairs of independent observations \((y_i, x_i)\) where \(y_i \in \mathbb{R}^p\) represents the outcome variable of the \(i^{th}\) observation and \(x_i \in \mathbb{R}^{m \times 1}\) represents the predictor variable of the \(i^{th}\) observation. The specification for this model is:
\[y_i = \beta^T x_i + \varepsilon_i, \quad \varepsilon_i \sim \mathcal{N}(0, \Sigma).\]
The parameters of the model include the coefficients of the predictor variables, \(\beta \in \mathbb{R}^{1 \times m}\) and the variance of the unmodelled noise, \(\Sigma \in \mathbb{R}^{p \times p}\).</description>
    </item>
    
    <item>
      <title>Multi-armed Bandits in Scala</title>
      <link>/2019/04/16/multi-armed-bandits/</link>
      <pubDate>Tue, 16 Apr 2019 00:00:00 +0000</pubDate>
      
      <guid>/2019/04/16/multi-armed-bandits/</guid>
      <description>Setting up the Environment This post uses Almond in order to run Scala code in a Jupyter notebook. See my previous post for my setup of Jupyter, Ammonite and Almond. That post examined using the Scala libraries EvilPlot (including inline plotting in the Jupyter notebook) and Rainier for Bayesian inference in a simple linear model.
The imports required for this post are:
import coursier.MavenRepository interp.repositories() ++= Seq(MavenRepository( &amp;quot;http://dl.bintray.com/cibotech/public&amp;quot; )) import $ivy.</description>
    </item>
    
    <item>
      <title>Scala and Jupyter Notebook with Almond</title>
      <link>/2019/04/15/scala-and-jupyter-notebook-with-almond/</link>
      <pubDate>Mon, 15 Apr 2019 00:00:00 +0000</pubDate>
      
      <guid>/2019/04/15/scala-and-jupyter-notebook-with-almond/</guid>
      <description>Typically, when programming with Scala I use a combination of ensime in emacs, sbt and the Scala repl. However, sometimes when working on a new project which requires a lot of data exploration and graphics it is sometimes more useful to have a notebook where figures are rendered inline with descriptions of why each figure has been generated and what it shows for future reference. Jupyter notebooks have long been the standard in Python (although I prefer rmarkdown and knitr when using R).</description>
    </item>
    
    <item>
      <title>Bayesian Inference using rejection sampling</title>
      <link>/2019/02/25/rejection-sampling/</link>
      <pubDate>Mon, 25 Feb 2019 00:00:00 +0000</pubDate>
      
      <guid>/2019/02/25/rejection-sampling/</guid>
      <description>Coin Flip Model As an example, consider a (possibly biased) coin flip experiment. The parameter of interest is the probability of heads \(p_h\). A Beta distribution is chosen for the prior of \(p_h\), \(p(p_h) = \mathcal{B}(\alpha, \beta)\). The Beta distribution has support between 0 and 1, which is appropriate for a probability. The likelihood of a coin flip is Bernoulli, however the coin should be flipped several times in order to learn the parameter \(p_h\).</description>
    </item>
    
    <item>
      <title>Sampling from a distribution with a known CDF</title>
      <link>/2019/02/25/inverse-sampling/</link>
      <pubDate>Mon, 25 Feb 2019 00:00:00 +0000</pubDate>
      
      <guid>/2019/02/25/inverse-sampling/</guid>
      <description>A distribution with an inverse cumulative distribution function (CDF) can be sampled from using just samples from \(U[0, 1]\). The inverse CDF (sometimes called the quantile function) is the value of \(x\) such that \(F_X(x) = Pr(X \leq x) = p\). Consider a that a transformation \(g: [0, 1] \rightarrow \mathbb{R}\), exists which takes a value sampled from the standard uniform distribution \(u \sim U[0, 1]\) and returns a value distributed according to the target distribution.</description>
    </item>
    
    <item>
      <title>National Cross Country</title>
      <link>/2019/02/22/national-cross-country/</link>
      <pubDate>Fri, 22 Feb 2019 00:00:00 +0000</pubDate>
      
      <guid>/2019/02/22/national-cross-country/</guid>
      <description>Area Results Download the results from Power of ten for northern, midlands, southern and national.
 A linear model The goal is to fit a model, where the outcome is the position at the national and the input is the position at the northern XC. This then allows us to determine the quality of the field at each XC and determine what position you are likely to finish in the National this season given a result in the area championships.</description>
    </item>
    
    <item>
      <title>Efficient Markov Chain Monte Carlo in R with Rcpp</title>
      <link>/2019/02/11/efficient_mcmc_using_rcpp/</link>
      <pubDate>Mon, 11 Feb 2019 00:00:00 +0000</pubDate>
      
      <guid>/2019/02/11/efficient_mcmc_using_rcpp/</guid>
      <description>Bivariate Normal Model This post considers how to implement a simple Metropolis scheme to determine the parameter posterior distribution of a bivariate Normal distribution. The implementation is generic, using higher-order-functions and hence can be re-used with new algorithms by specifying the un-normalised log-posterior density and a proposal distribution for the parameters. The built-in parallel package is used fit multiple chains in parallel, finally the Metropolis algorithm is reimplemented in C++ using Rcpp which seemlessly integrates with R.</description>
    </item>
    
    <item>
      <title>Harrier League Cross Country</title>
      <link>/2017/10/26/harrier-league-cross-country/</link>
      <pubDate>Thu, 26 Oct 2017 00:00:00 +0000</pubDate>
      
      <guid>/2017/10/26/harrier-league-cross-country/</guid>
      <description>The Harrier League is a cross country running league with seven fixtures across the North East of England in the 2017/18 season across the winter months from September ’17 until March ‘18.
The Harrier League is unique to other cross country fixtures because the senior runners are divided up into slow, medium and fast packs. In the senior men’s race, the slow runners start first followed 2 minutes 30 seconds later by the medium pack runners, then a further 2 minutes 30 seconds by the fast pack runners.</description>
    </item>
    
    <item>
      <title>MCMC with Scala Breeze</title>
      <link>/2017/04/23/mcmc-with-scala-breeze/</link>
      <pubDate>Sun, 23 Apr 2017 14:13:12 -0500</pubDate>
      
      <guid>/2017/04/23/mcmc-with-scala-breeze/</guid>
      <description>Bivariate Gaussian Model Scala Breeze is a numerical computing library, which also provides facilities for statistical computing. For instance, implementations of distributions and Markov Chain Monte Carlo for, typically used for Bayesian inference of intractable models. Today I am going to build a simple bivariate Gaussian model, simulate some realisations from the model and use the Breeze library to recover the mean of the bivariate Gaussian distribution and the variance.</description>
    </item>
    
    <item>
      <title>An Akka HTTP Client with JSON Parsing</title>
      <link>/2017/02/21/an-akka-http-client-with-json-parsing/</link>
      <pubDate>Tue, 21 Feb 2017 12:13:14 -0500</pubDate>
      
      <guid>/2017/02/21/an-akka-http-client-with-json-parsing/</guid>
      <description>There are many sources of open data on the web, freely accessible via an Application Programming Interface (API) made available over the web. A common interchange format for these APIs is Javascript Object Notation (JSON) which is human readable and predictable, however is not in the correct format for analysis. The data needs to be parsed from the JSON string and made available as an object we can work with.</description>
    </item>
    
    <item>
      <title>Using Monads for Handling Failures and Exceptions</title>
      <link>/2017/01/04/using-monads-for-handling-failures-and-exceptions/</link>
      <pubDate>Wed, 04 Jan 2017 12:13:14 -0500</pubDate>
      
      <guid>/2017/01/04/using-monads-for-handling-failures-and-exceptions/</guid>
      <description>In this post I will give a practical introduction to some useful structures for handling failure in functional programming.
Referential Transparency One of the most important properties of functional programming is referential transparency and programming with pure functions. This means we can substitute a pure function with its result, for intance if we have the function def f = 1 + 2, we can replace every occurence of f with 3 and the final evaluation will remain unchanged</description>
    </item>
    
    <item>
      <title>Seasonal DLM</title>
      <link>/2016/12/13/seasonal-dlm/</link>
      <pubDate>Tue, 13 Dec 2016 12:13:14 -0500</pubDate>
      
      <guid>/2016/12/13/seasonal-dlm/</guid>
      <description>The Seasonal DLM I introduced the class of state space models called DLMs in a previous post covering the Kalman Filter. The seasonal DLM is similar to the first order DLM, however it incorporates a deterministic transformation to the state, in order to capture cyclic trends. Remember a general DLM can be written as:
\[\begin{align} y_t &amp;amp;= F_t x_t + \nu_t, \qquad \mathcal{N}(0, V_t), \\ x_t &amp;amp;= G_t x_{t-1} + \omega_t, \quad \mathcal{N}(0, W_t).</description>
    </item>
    
    <item>
      <title>The Kalman Filter in Scala</title>
      <link>/2016/12/12/the-kalman-filter-in-scala/</link>
      <pubDate>Mon, 12 Dec 2016 12:13:14 -0500</pubDate>
      
      <guid>/2016/12/12/the-kalman-filter-in-scala/</guid>
      <description>A Dynamic Linear Model (DLM) is a special type of state space model, where the state and observation equations are Normally distributed and linear. A general DLM can be written as follows:
\[\begin{aligned} y_t &amp;amp;= F_t x_t + \nu_t, \qquad \nu_t \sim \mathcal{N}(0, V_t) \\ x_t &amp;amp;= G_tx_{t-1} + \omega_t \qquad \omega_t \sim \mathcal{N}(0, W_t), \end{aligned}\]
\(y_t\) represents the observation of the process at time \(t\), \(x_t\) is the value of the unobserved state at time \(t\).</description>
    </item>
    
    <item>
      <title>Practical Introduction to Akka Streaming</title>
      <link>/2016/12/01/practical-introduction-to-akka-streaming/</link>
      <pubDate>Thu, 01 Dec 2016 12:13:14 -0500</pubDate>
      
      <guid>/2016/12/01/practical-introduction-to-akka-streaming/</guid>
      <description>Akka Streaming is a streaming IO engine used to build high performance, fault tolerant and scalable streaming data services. In this post I will describe how you can implement some of the features included in Akka Streaming using only simple streams of integers and strings, although the true power of Akka streams only becomes apparent when we are consuming data from real sources such as Websockets, databases and files. Akka is available in Java and Scala, but I will be focusing on the Scala API in this post.</description>
    </item>
    
  </channel>
</rss>