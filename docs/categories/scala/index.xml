<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Probabilistic Programming in Scala</title>
    <link>/categories/scala/index.xml</link>
    <description>Recent content on Probabilistic Programming in Scala</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <atom:link href="/categories/scala/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>The Kalman Filter in Scala</title>
      <link>/blog/KalmanFilter/</link>
      <pubDate>Mon, 12 Dec 2016 12:13:14 -0500</pubDate>
      
      <guid>/blog/KalmanFilter/</guid>
      <description>---
title: &#34;The Kalman Filter in Scala&#34;
author: &#34;Jonny Law&#34;
date: &#39;2016-12-12T12:13:14-05:00&#39;
categories: scala
---


&lt;!-- BLOGDOWN-BODY-BEFORE

/BLOGDOWN-BODY-BEFORE --&gt;

&lt;p&gt;A Dynamic Linear Model (DLM) is a special type of state space model, where the state and observation equations are Normally distributed and linear. A general DLM can be written as follows:&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[\begin{aligned} y_t &amp;amp;= F_t x_t + \nu_t, \qquad \nu_t \sim \mathcal{N}(0, V_t) \\
x_t &amp;amp;= G_tx_{t-1} + \omega_t \qquad \omega_t \sim \mathcal{N}(0, W_t), \end{aligned}\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math inline&#34;&gt;\(y_t\)&lt;/span&gt; represents the observation of the process at time &lt;span class=&#34;math inline&#34;&gt;\(t\)&lt;/span&gt;, &lt;span class=&#34;math inline&#34;&gt;\(x_t\)&lt;/span&gt; is the value of the unobserved state at time &lt;span class=&#34;math inline&#34;&gt;\(t\)&lt;/span&gt;. The observation error &lt;span class=&#34;math inline&#34;&gt;\(\nu_t\)&lt;/span&gt; and the system error &lt;span class=&#34;math inline&#34;&gt;\(\omega_t\)&lt;/span&gt; are independent and identically distributed (iid) Normal random variables. &lt;span class=&#34;math inline&#34;&gt;\(F_t\)&lt;/span&gt; is the observation matrix which transforms the state space to the observation, &lt;span class=&#34;math inline&#34;&gt;\(G_t\)&lt;/span&gt; is the state transition matrix.&lt;/p&gt;
&lt;div id=&#34;forward-simulating-from-the-dlm&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Forward Simulating from the DLM&lt;/h2&gt;
&lt;p&gt;A first order polynomial DLM with constant &lt;span class=&#34;math inline&#34;&gt;\(V\)&lt;/span&gt; and &lt;span class=&#34;math inline&#34;&gt;\(W\)&lt;/span&gt;, and &lt;span class=&#34;math inline&#34;&gt;\(F_t = 1\)&lt;/span&gt;, &lt;span class=&#34;math inline&#34;&gt;\(G_t = 1\)&lt;/span&gt;. can be simulated in scala as follows:&lt;/p&gt;
&lt;pre class=&#34;scala&#34;&gt;&lt;code&gt;import breeze.stats.distributions.Gaussian

case class Data(time: Time, observation: Observation, state: Option[State])
case class Parameters(v: Double, w: Double, m0: Double, c0: Double)

def simulate(p: Parameters): Stream[Data] = {
val stateSpace = Stream.iterate(Gaussian(p.m0, sqrt(p.c0)).draw)(x =&amp;gt; Gaussian(x, sqrt(p.w)).draw)
  stateSpace.zipWithIndex map { case (x, t) =&amp;gt;
    Data(t, x + Gaussian(0, sqrt(p.v)).draw, Some(x)) 
  }
}

val p = Parameters(3.0, 0.5, 0.0, 10.0)
// simulate 16 different realisations of 100 observations, representing 16 stations
val data = (1 to 16) map (id =&amp;gt; (id, simulate(p).take(100).toVector))&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We use the built in streaming library’s &lt;code&gt;iterate&lt;/code&gt; function to specify the evolution of the latent state. The initial state &lt;span class=&#34;math inline&#34;&gt;\(x_0\)&lt;/span&gt; is a sample drawn from a normal distribution with mean &lt;span class=&#34;math inline&#34;&gt;\(m_0\)&lt;/span&gt; and variance &lt;span class=&#34;math inline&#34;&gt;\(C_0\)&lt;/span&gt;, &lt;span class=&#34;math inline&#34;&gt;\(x_t \sim \mathcal{N}(x_0 | m_0, C_0)\)&lt;/span&gt;. The &lt;a href=&#34;https://github.com/scalanlp/breeze/&#34;&gt;Breeze numerical computing library&lt;/a&gt; provides many statistical and mathematical functions is used. Subsequent states are generated by adding &lt;span class=&#34;math inline&#34;&gt;\(\mathcal{N}(0, W)\)&lt;/span&gt; to the previous state:&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[x_t = x_{t-1} + \omega, \qquad \omega \sim \mathcal{N}(0, V)\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;We then construct a &lt;code&gt;Stream&lt;/code&gt; of &lt;code&gt;Data&lt;/code&gt; objects. The &lt;code&gt;Data&lt;/code&gt; object has a timestamped observation and an optional state space. We construct the observation at time &lt;span class=&#34;math inline&#34;&gt;\(t\)&lt;/span&gt; by simply adding the observation noise to the state space &lt;span class=&#34;math inline&#34;&gt;\(y_t \sim \mathcal{N}(y_t | x_t, V)\)&lt;/span&gt;. The state is optional because we can’t observe the state of real data, only simulated data will have a known state.&lt;/p&gt;
&lt;p&gt;A graph of the data from four “stations”, produced using &lt;a href=&#34;http://ggplot2.org&#34;&gt;ggplot2&lt;/a&gt; in R is shown in the figure below.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;#####../content/post/KalmanFilter_files/figure-html/unnamed-chunk-1-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;div id=&#34;an-aside-on-referential-transparency&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;An Aside on Referential Transparency&lt;/h3&gt;
&lt;p&gt;Note that the function &lt;code&gt;simulate&lt;/code&gt; is not referentially transparent, meaning the function will return a different &lt;code&gt;Stream&lt;/code&gt; of data each time we run it. Referential transparency is important in functional programming, to allow us to easily reason about complex programs. The Breeze library implements another object for stateful random number generation, the &lt;code&gt;Process&lt;/code&gt; object. The &lt;code&gt;MarkovChain&lt;/code&gt; object can be used to construct a process without drawing explicitly from the distribution until we run the program. Firstly define a single step of the random walk:&lt;/p&gt;
&lt;pre class=&#34;scala&#34;&gt;&lt;code&gt;import breeze.stats.distributions._

def step_rw(p: Parameters): Double =&amp;gt; Rand[Double] = 
  x =&amp;gt; Gaussian(x, p.w)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If &lt;code&gt;step_rw&lt;/code&gt; is supplied with a set of &lt;code&gt;Parameters&lt;/code&gt;, it returns a function from the current state, which is assumed to be materialised, to the next state, which is a &lt;code&gt;Rand[Double]&lt;/code&gt;. The actual random number isn’t generated until we sample from distribution represented by &lt;code&gt;Rand&lt;/code&gt;. Next, we can construct a &lt;code&gt;MarkovChain&lt;/code&gt; using the transition kernel &lt;code&gt;stepRw&lt;/code&gt;:&lt;/p&gt;
&lt;pre class=&#34;scala&#34;&gt;&lt;code&gt;val random_walk: Process[Double] = MarkovChain(0.0)(step_rw(p))
random_walk.
  steps.
  take(100)&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id=&#34;the-kalman-filter&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;The Kalman Filter&lt;/h2&gt;
&lt;p&gt;The Kalman Filter can be used to determine the posterior distribution of the state space given the current observation and the &lt;span class=&#34;math inline&#34;&gt;\(p(x_t|D_{t})\)&lt;/span&gt;, where &lt;span class=&#34;math inline&#34;&gt;\(D_t = \{Y_t, D_{t-1}\}\)&lt;/span&gt; and &lt;span class=&#34;math inline&#34;&gt;\(D_0\)&lt;/span&gt; is the initial information, comprising of the parameters mode parameters &lt;span class=&#34;math inline&#34;&gt;\(W_0\)&lt;/span&gt; and &lt;span class=&#34;math inline&#34;&gt;\(V_0\)&lt;/span&gt; and the initial state &lt;span class=&#34;math inline&#34;&gt;\(x_0 \sim N(m_0, C_0)\)&lt;/span&gt;. The full treatment of the Kalman Filter can be found in the excellent Bayesian Forecasting for Dynamic Models by West and Harrison.&lt;/p&gt;
&lt;p&gt;I will present the filtering equations for the simple model in this post. Suppose we start with the posterior distribution of &lt;span class=&#34;math inline&#34;&gt;\(x_{t-1} \sim N(m_{t-1}, C_{t-1})\)&lt;/span&gt;. The first thing we need to do is advance the state, the equation to advance the state is a simple Markov transition &lt;span class=&#34;math inline&#34;&gt;\(x_t = x_{t-1} + \omega_t\)&lt;/span&gt;. We simply add the system variance, the system variance is drawn from a Normal distribution with zero mean and variance &lt;span class=&#34;math inline&#34;&gt;\(W\)&lt;/span&gt;. The &lt;a href=&#34;https://en.wikipedia.org/wiki/Sum_of_normally_distributed_random_variables&#34;&gt;sum of two Normal distributions is Normal&lt;/a&gt; with the mean and variance added, hence the prior for &lt;span class=&#34;math inline&#34;&gt;\((x_t | D_{t-1}) \sim N(m_{t-1}, C_{t-1} + W)\)&lt;/span&gt;.&lt;/p&gt;
&lt;p&gt;Next we need to construct the observation, using the observation equation which is commonly called the one-step forecast for the series, &lt;span class=&#34;math inline&#34;&gt;\(y_t = x_t + \nu_t\)&lt;/span&gt;, since &lt;span class=&#34;math inline&#34;&gt;\(\nu_t\)&lt;/span&gt; is Normally distributed with zero mean and variance &lt;span class=&#34;math inline&#34;&gt;\(V\)&lt;/span&gt;, the distribution of the one step forecast is, &lt;span class=&#34;math inline&#34;&gt;\((y_t|D_{t-1}) \sim N(m_{t-1}, C_{t-1} + W + V)\)&lt;/span&gt;.&lt;/p&gt;
&lt;p&gt;Now, we observe the true value of &lt;span class=&#34;math inline&#34;&gt;\(y_t\)&lt;/span&gt; and are able to construct the posterior distribution of &lt;span class=&#34;math inline&#34;&gt;\((x_t | D_t) \sim N(m_t, C_t)\)&lt;/span&gt;. &lt;span class=&#34;math inline&#34;&gt;\(m_t = m_{t-1} + A_t e_t\)&lt;/span&gt; and &lt;span class=&#34;math inline&#34;&gt;\(C_t = A_tV\)&lt;/span&gt;. &lt;span class=&#34;math inline&#34;&gt;\(A_t = \frac{C_{t-1} + W}{ C_{t-1} + W + V}\)&lt;/span&gt; is known as the regression coefficient, and &lt;span class=&#34;math inline&#34;&gt;\(e_t = Y_t - m_{t-1}\)&lt;/span&gt;. This result can be shown using properties of the multivariate normal distribution, and is presented in full in Bayesian Forecasting for Dynamic Models by West and Harrison.&lt;/p&gt;
&lt;p&gt;We now have the equations required to program up the Kalman Filter using Scala.&lt;/p&gt;
&lt;pre class=&#34;scala&#34;&gt;&lt;code&gt;case class FilterState(data: Data, p: Parameters)

def filter(p: Parameters): (FilterState, Data) =&amp;gt; FilterState = (s, d) =&amp;gt; {
  val r = s.p.c0 + p.w
  val q = r + p.v
  val e = d.observation - s.p.m0

  // kalman gain
  val k = r / q
  val c1 = k * p.v
  
  // return the data with the expectation of the hidden state and the updated Parameters
  FilterOut(Data(d.time, d.observation, Some(m1)), Parameters(p.v, p.w, m1, c1))
} &lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The function filter simply takes in &lt;code&gt;Parameters&lt;/code&gt; and one observation, represented by &lt;code&gt;Data&lt;/code&gt; and returns the updated parameters required for the next step of the filter. Now we need to write a function which filters a sequence of &lt;code&gt;Data&lt;/code&gt;, and returns a sequence consisting of the latent states, which we can do using the function &lt;code&gt;scanLeft&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;A simplified function signature of &lt;code&gt;scanLeft&lt;/code&gt; is given by: &lt;code&gt;scanLeft[A](l: List[A], z: A)(f: (A, A) =&amp;gt; A): List[A]&lt;/code&gt;. A list, &lt;code&gt;l&lt;/code&gt; with elements of type &lt;code&gt;A&lt;/code&gt; and an initial value, &lt;code&gt;z&lt;/code&gt; also of type &lt;code&gt;A&lt;/code&gt; if passed to a &lt;code&gt;Function2&lt;/code&gt; and accumulated into another list with elements of type &lt;code&gt;A&lt;/code&gt;. The function &lt;code&gt;f&lt;/code&gt; is applied to each element of the list pairwise, starting the the head of the lift and the zero element, &lt;code&gt;z&lt;/code&gt;. Consider calculating the &lt;code&gt;sum&lt;/code&gt; of a list of numbers:&lt;/p&gt;
&lt;pre class=&#34;scala&#34;&gt;&lt;code&gt;val numbers = List(1,2,3,4,5)
def sum(a: Int, b: Int): Int = a + b

numbers.scanLeft(0)(sum)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The first calculation is (0 + 1) = 1, which is then used as the first argument in the pairwise &lt;code&gt;sum&lt;/code&gt; function, then the second calculation is (1 + 2) = 3, the result of which is used again in the next application of &lt;code&gt;sum&lt;/code&gt;. Each intermediate step of the calculation is retained and appended to a list to be output when the list of number is exhausted, so we end up with a cumulative sum, &lt;code&gt;List(0, 1, 3, 6, 10, 15)&lt;/code&gt;. We can use &lt;code&gt;scanLeft&lt;/code&gt; and the &lt;code&gt;Function2&lt;/code&gt;, &lt;code&gt;filter&lt;/code&gt; to calculate and retain the latent states in a DLM:&lt;/p&gt;
&lt;pre class=&#34;scala&#34;&gt;&lt;code&gt;def filterSeries(data: Seq[Data], initParams: Parameters): Seq[FilterOut] = {
  val initFilter = FilterState(data.head, params, 0.0) // initialise the filter

  data.
    scanLeft(initFilter)(filter(initParams)).
    drop(1)
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now, we can apply the filter to all the stations simultaneously:&lt;/p&gt;
&lt;pre class=&#34;scala&#34;&gt;&lt;code&gt;data.
  groupBy{ case (id, _) =&amp;gt; id }. //groups by id
  map{ case (id, idAndData) =&amp;gt;
  (id, idAndData map (x =&amp;gt; x._2)) }. // changes into (id, data) pairs
  map{ case (id, data) =&amp;gt;
  (id, filterSeries(data.sortBy(_.time), p)) } // apply the filter to the sorted data&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We can now plot the results of the filtering using R and ggplot2, overlaid with 95% prediction intervals.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;#####../content/post/KalmanFilter_files/figure-html/unnamed-chunk-3-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;p&gt;The full code is available in the &lt;a href=&#34;https://github.com/jonnylaw/blog/tree/master/dlm&#34;&gt;GitHub Repo&lt;/a&gt; associated with this blog.&lt;/p&gt;
&lt;/div&gt;


&lt;!-- dynamically load mathjax for compatibility with self-contained --&gt;
&lt;script&gt;
  (function () {
    var script = document.createElement(&#34;script&#34;);
    script.type = &#34;text/javascript&#34;;
    script.src  = &#34;https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML&#34;;
    if (location.protocol !== &#34;file:&#34; &amp;&amp; /^https?:/.test(script.src))
      script.src  = script.src.replace(/^https?:/, &#39;&#39;);
    document.getElementsByTagName(&#34;head&#34;)[0].appendChild(script);
  })();
&lt;/script&gt;

&lt;!-- BLOGDOWN-HEAD






/BLOGDOWN-HEAD --&gt;
</description>
    </item>
    
    <item>
      <title>The Kalman Filter in Scala</title>
      <link>/post/KalmanFilter/</link>
      <pubDate>Mon, 12 Dec 2016 12:13:14 -0500</pubDate>
      
      <guid>/post/KalmanFilter/</guid>
      <description>&lt;!-- BLOGDOWN-BODY-BEFORE

/BLOGDOWN-BODY-BEFORE --&gt;

&lt;p&gt;A Dynamic Linear Model (DLM) is a special type of state space model, where the state and observation equations are Normally distributed and linear. A general DLM can be written as follows:&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[\begin{aligned} y_t &amp;amp;= F_t x_t + \nu_t, \qquad \nu_t \sim \mathcal{N}(0, V_t) \\
x_t &amp;amp;= G_tx_{t-1} + \omega_t \qquad \omega_t \sim \mathcal{N}(0, W_t), \end{aligned}\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math inline&#34;&gt;\(y_t\)&lt;/span&gt; represents the observation of the process at time &lt;span class=&#34;math inline&#34;&gt;\(t\)&lt;/span&gt;, &lt;span class=&#34;math inline&#34;&gt;\(x_t\)&lt;/span&gt; is the value of the unobserved state at time &lt;span class=&#34;math inline&#34;&gt;\(t\)&lt;/span&gt;. The observation error &lt;span class=&#34;math inline&#34;&gt;\(\nu_t\)&lt;/span&gt; and the system error &lt;span class=&#34;math inline&#34;&gt;\(\omega_t\)&lt;/span&gt; are independent and identically distributed (iid) Normal random variables. &lt;span class=&#34;math inline&#34;&gt;\(F_t\)&lt;/span&gt; is the observation matrix which transforms the state space to the observation, &lt;span class=&#34;math inline&#34;&gt;\(G_t\)&lt;/span&gt; is the state transition matrix.&lt;/p&gt;
&lt;div id=&#34;forward-simulating-from-the-dlm&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Forward Simulating from the DLM&lt;/h2&gt;
&lt;p&gt;A first order polynomial DLM with constant &lt;span class=&#34;math inline&#34;&gt;\(V\)&lt;/span&gt; and &lt;span class=&#34;math inline&#34;&gt;\(W\)&lt;/span&gt;, and &lt;span class=&#34;math inline&#34;&gt;\(F_t = 1\)&lt;/span&gt;, &lt;span class=&#34;math inline&#34;&gt;\(G_t = 1\)&lt;/span&gt;. can be simulated in scala as follows:&lt;/p&gt;
&lt;pre class=&#34;scala&#34;&gt;&lt;code&gt;import breeze.stats.distributions.Gaussian

case class Data(time: Time, observation: Observation, state: Option[State])
case class Parameters(v: Double, w: Double, m0: Double, c0: Double)

def simulate(p: Parameters): Stream[Data] = {
val stateSpace = Stream.iterate(Gaussian(p.m0, sqrt(p.c0)).draw)(x =&amp;gt; Gaussian(x, sqrt(p.w)).draw)
  stateSpace.zipWithIndex map { case (x, t) =&amp;gt;
    Data(t, x + Gaussian(0, sqrt(p.v)).draw, Some(x)) 
  }
}

val p = Parameters(3.0, 0.5, 0.0, 10.0)
// simulate 16 different realisations of 100 observations, representing 16 stations
val data = (1 to 16) map (id =&amp;gt; (id, simulate(p).take(100).toVector))&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We use the built in streaming library’s &lt;code&gt;iterate&lt;/code&gt; function to specify the evolution of the latent state. The initial state &lt;span class=&#34;math inline&#34;&gt;\(x_0\)&lt;/span&gt; is a sample drawn from a normal distribution with mean &lt;span class=&#34;math inline&#34;&gt;\(m_0\)&lt;/span&gt; and variance &lt;span class=&#34;math inline&#34;&gt;\(C_0\)&lt;/span&gt;, &lt;span class=&#34;math inline&#34;&gt;\(x_t \sim \mathcal{N}(x_0 | m_0, C_0)\)&lt;/span&gt;. The &lt;a href=&#34;https://github.com/scalanlp/breeze/&#34;&gt;Breeze numerical computing library&lt;/a&gt; provides many statistical and mathematical functions is used. Subsequent states are generated by adding &lt;span class=&#34;math inline&#34;&gt;\(\mathcal{N}(0, W)\)&lt;/span&gt; to the previous state:&lt;/p&gt;
&lt;p&gt;&lt;span class=&#34;math display&#34;&gt;\[x_t = x_{t-1} + \omega, \qquad \omega \sim \mathcal{N}(0, V)\]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;We then construct a &lt;code&gt;Stream&lt;/code&gt; of &lt;code&gt;Data&lt;/code&gt; objects. The &lt;code&gt;Data&lt;/code&gt; object has a timestamped observation and an optional state space. We construct the observation at time &lt;span class=&#34;math inline&#34;&gt;\(t\)&lt;/span&gt; by simply adding the observation noise to the state space &lt;span class=&#34;math inline&#34;&gt;\(y_t \sim \mathcal{N}(y_t | x_t, V)\)&lt;/span&gt;. The state is optional because we can’t observe the state of real data, only simulated data will have a known state.&lt;/p&gt;
&lt;p&gt;A graph of the data from four “stations”, produced using &lt;a href=&#34;http://ggplot2.org&#34;&gt;ggplot2&lt;/a&gt; in R is shown in the figure below.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;#####../content/post/KalmanFilter_files/figure-html/unnamed-chunk-1-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;div id=&#34;an-aside-on-referential-transparency&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;An Aside on Referential Transparency&lt;/h3&gt;
&lt;p&gt;Note that the function &lt;code&gt;simulate&lt;/code&gt; is not referentially transparent, meaning the function will return a different &lt;code&gt;Stream&lt;/code&gt; of data each time we run it. Referential transparency is important in functional programming, to allow us to easily reason about complex programs. The Breeze library implements another object for stateful random number generation, the &lt;code&gt;Process&lt;/code&gt; object. The &lt;code&gt;MarkovChain&lt;/code&gt; object can be used to construct a process without drawing explicitly from the distribution until we run the program. Firstly define a single step of the random walk:&lt;/p&gt;
&lt;pre class=&#34;scala&#34;&gt;&lt;code&gt;import breeze.stats.distributions._

def step_rw(p: Parameters): Double =&amp;gt; Rand[Double] = 
  x =&amp;gt; Gaussian(x, p.w)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;If &lt;code&gt;step_rw&lt;/code&gt; is supplied with a set of &lt;code&gt;Parameters&lt;/code&gt;, it returns a function from the current state, which is assumed to be materialised, to the next state, which is a &lt;code&gt;Rand[Double]&lt;/code&gt;. The actual random number isn’t generated until we sample from distribution represented by &lt;code&gt;Rand&lt;/code&gt;. Next, we can construct a &lt;code&gt;MarkovChain&lt;/code&gt; using the transition kernel &lt;code&gt;stepRw&lt;/code&gt;:&lt;/p&gt;
&lt;pre class=&#34;scala&#34;&gt;&lt;code&gt;val random_walk: Process[Double] = MarkovChain(0.0)(step_rw(p))
random_walk.
  steps.
  take(100)&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id=&#34;the-kalman-filter&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;The Kalman Filter&lt;/h2&gt;
&lt;p&gt;The Kalman Filter can be used to determine the posterior distribution of the state space given the current observation and the &lt;span class=&#34;math inline&#34;&gt;\(p(x_t|D_{t})\)&lt;/span&gt;, where &lt;span class=&#34;math inline&#34;&gt;\(D_t = \{Y_t, D_{t-1}\}\)&lt;/span&gt; and &lt;span class=&#34;math inline&#34;&gt;\(D_0\)&lt;/span&gt; is the initial information, comprising of the parameters mode parameters &lt;span class=&#34;math inline&#34;&gt;\(W_0\)&lt;/span&gt; and &lt;span class=&#34;math inline&#34;&gt;\(V_0\)&lt;/span&gt; and the initial state &lt;span class=&#34;math inline&#34;&gt;\(x_0 \sim N(m_0, C_0)\)&lt;/span&gt;. The full treatment of the Kalman Filter can be found in the excellent Bayesian Forecasting for Dynamic Models by West and Harrison.&lt;/p&gt;
&lt;p&gt;I will present the filtering equations for the simple model in this post. Suppose we start with the posterior distribution of &lt;span class=&#34;math inline&#34;&gt;\(x_{t-1} \sim N(m_{t-1}, C_{t-1})\)&lt;/span&gt;. The first thing we need to do is advance the state, the equation to advance the state is a simple Markov transition &lt;span class=&#34;math inline&#34;&gt;\(x_t = x_{t-1} + \omega_t\)&lt;/span&gt;. We simply add the system variance, the system variance is drawn from a Normal distribution with zero mean and variance &lt;span class=&#34;math inline&#34;&gt;\(W\)&lt;/span&gt;. The &lt;a href=&#34;https://en.wikipedia.org/wiki/Sum_of_normally_distributed_random_variables&#34;&gt;sum of two Normal distributions is Normal&lt;/a&gt; with the mean and variance added, hence the prior for &lt;span class=&#34;math inline&#34;&gt;\((x_t | D_{t-1}) \sim N(m_{t-1}, C_{t-1} + W)\)&lt;/span&gt;.&lt;/p&gt;
&lt;p&gt;Next we need to construct the observation, using the observation equation which is commonly called the one-step forecast for the series, &lt;span class=&#34;math inline&#34;&gt;\(y_t = x_t + \nu_t\)&lt;/span&gt;, since &lt;span class=&#34;math inline&#34;&gt;\(\nu_t\)&lt;/span&gt; is Normally distributed with zero mean and variance &lt;span class=&#34;math inline&#34;&gt;\(V\)&lt;/span&gt;, the distribution of the one step forecast is, &lt;span class=&#34;math inline&#34;&gt;\((y_t|D_{t-1}) \sim N(m_{t-1}, C_{t-1} + W + V)\)&lt;/span&gt;.&lt;/p&gt;
&lt;p&gt;Now, we observe the true value of &lt;span class=&#34;math inline&#34;&gt;\(y_t\)&lt;/span&gt; and are able to construct the posterior distribution of &lt;span class=&#34;math inline&#34;&gt;\((x_t | D_t) \sim N(m_t, C_t)\)&lt;/span&gt;. &lt;span class=&#34;math inline&#34;&gt;\(m_t = m_{t-1} + A_t e_t\)&lt;/span&gt; and &lt;span class=&#34;math inline&#34;&gt;\(C_t = A_tV\)&lt;/span&gt;. &lt;span class=&#34;math inline&#34;&gt;\(A_t = \frac{C_{t-1} + W}{ C_{t-1} + W + V}\)&lt;/span&gt; is known as the regression coefficient, and &lt;span class=&#34;math inline&#34;&gt;\(e_t = Y_t - m_{t-1}\)&lt;/span&gt;. This result can be shown using properties of the multivariate normal distribution, and is presented in full in Bayesian Forecasting for Dynamic Models by West and Harrison.&lt;/p&gt;
&lt;p&gt;We now have the equations required to program up the Kalman Filter using Scala.&lt;/p&gt;
&lt;pre class=&#34;scala&#34;&gt;&lt;code&gt;case class FilterState(data: Data, p: Parameters)

def filter(p: Parameters): (FilterState, Data) =&amp;gt; FilterState = (s, d) =&amp;gt; {
  val r = s.p.c0 + p.w
  val q = r + p.v
  val e = d.observation - s.p.m0

  // kalman gain
  val k = r / q
  val c1 = k * p.v
  
  // return the data with the expectation of the hidden state and the updated Parameters
  FilterOut(Data(d.time, d.observation, Some(m1)), Parameters(p.v, p.w, m1, c1))
} &lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The function filter simply takes in &lt;code&gt;Parameters&lt;/code&gt; and one observation, represented by &lt;code&gt;Data&lt;/code&gt; and returns the updated parameters required for the next step of the filter. Now we need to write a function which filters a sequence of &lt;code&gt;Data&lt;/code&gt;, and returns a sequence consisting of the latent states, which we can do using the function &lt;code&gt;scanLeft&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;A simplified function signature of &lt;code&gt;scanLeft&lt;/code&gt; is given by: &lt;code&gt;scanLeft[A](l: List[A], z: A)(f: (A, A) =&amp;gt; A): List[A]&lt;/code&gt;. A list, &lt;code&gt;l&lt;/code&gt; with elements of type &lt;code&gt;A&lt;/code&gt; and an initial value, &lt;code&gt;z&lt;/code&gt; also of type &lt;code&gt;A&lt;/code&gt; if passed to a &lt;code&gt;Function2&lt;/code&gt; and accumulated into another list with elements of type &lt;code&gt;A&lt;/code&gt;. The function &lt;code&gt;f&lt;/code&gt; is applied to each element of the list pairwise, starting the the head of the lift and the zero element, &lt;code&gt;z&lt;/code&gt;. Consider calculating the &lt;code&gt;sum&lt;/code&gt; of a list of numbers:&lt;/p&gt;
&lt;pre class=&#34;scala&#34;&gt;&lt;code&gt;val numbers = List(1,2,3,4,5)
def sum(a: Int, b: Int): Int = a + b

numbers.scanLeft(0)(sum)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The first calculation is (0 + 1) = 1, which is then used as the first argument in the pairwise &lt;code&gt;sum&lt;/code&gt; function, then the second calculation is (1 + 2) = 3, the result of which is used again in the next application of &lt;code&gt;sum&lt;/code&gt;. Each intermediate step of the calculation is retained and appended to a list to be output when the list of number is exhausted, so we end up with a cumulative sum, &lt;code&gt;List(0, 1, 3, 6, 10, 15)&lt;/code&gt;. We can use &lt;code&gt;scanLeft&lt;/code&gt; and the &lt;code&gt;Function2&lt;/code&gt;, &lt;code&gt;filter&lt;/code&gt; to calculate and retain the latent states in a DLM:&lt;/p&gt;
&lt;pre class=&#34;scala&#34;&gt;&lt;code&gt;def filterSeries(data: Seq[Data], initParams: Parameters): Seq[FilterOut] = {
  val initFilter = FilterState(data.head, params, 0.0) // initialise the filter

  data.
    scanLeft(initFilter)(filter(initParams)).
    drop(1)
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now, we can apply the filter to all the stations simultaneously:&lt;/p&gt;
&lt;pre class=&#34;scala&#34;&gt;&lt;code&gt;data.
  groupBy{ case (id, _) =&amp;gt; id }. //groups by id
  map{ case (id, idAndData) =&amp;gt;
  (id, idAndData map (x =&amp;gt; x._2)) }. // changes into (id, data) pairs
  map{ case (id, data) =&amp;gt;
  (id, filterSeries(data.sortBy(_.time), p)) } // apply the filter to the sorted data&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We can now plot the results of the filtering using R and ggplot2, overlaid with 95% prediction intervals.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;#####../content/post/KalmanFilter_files/figure-html/unnamed-chunk-3-1.png&#34; width=&#34;672&#34; /&gt;&lt;/p&gt;
&lt;p&gt;The full code is available in the &lt;a href=&#34;https://github.com/jonnylaw/blog/tree/master/dlm&#34;&gt;GitHub Repo&lt;/a&gt; associated with this blog.&lt;/p&gt;
&lt;/div&gt;


&lt;!-- dynamically load mathjax for compatibility with self-contained --&gt;
&lt;script&gt;
  (function () {
    var script = document.createElement(&#34;script&#34;);
    script.type = &#34;text/javascript&#34;;
    script.src  = &#34;https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML&#34;;
    if (location.protocol !== &#34;file:&#34; &amp;&amp; /^https?:/.test(script.src))
      script.src  = script.src.replace(/^https?:/, &#39;&#39;);
    document.getElementsByTagName(&#34;head&#34;)[0].appendChild(script);
  })();
&lt;/script&gt;

&lt;!-- BLOGDOWN-HEAD






/BLOGDOWN-HEAD --&gt;
</description>
    </item>
    
    <item>
      <title>Practical Introduction to Akka Streaming</title>
      <link>/post/PracticalAkkaStreams/</link>
      <pubDate>Thu, 01 Dec 2016 12:13:14 -0500</pubDate>
      
      <guid>/post/PracticalAkkaStreams/</guid>
      <description>&lt;!-- BLOGDOWN-BODY-BEFORE

/BLOGDOWN-BODY-BEFORE --&gt;

&lt;p&gt;&lt;a href=&#34;%22http://akka.io%22&#34;&gt;Akka Streaming&lt;/a&gt; is a streaming IO engine used to build high performance, fault tolerant and scalable streaming data services. In this post I will describe how you can implement some of the features included in Akka Streaming using only simple streams of integers and strings, although the true power of Akka streams only becomes apparent when we are consuming data from real sources such as Websockets, databases and files. Akka is available in Java and Scala, but I will be focusing on the Scala API in this post.&lt;/p&gt;
&lt;div id=&#34;building-a-new-sbt-project&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Building a new SBT Project&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;http://www.scala-sbt.org/&#34;&gt;Simple Build Tool&lt;/a&gt; is the most used build tool of Scala developers, despite the name it is incredibly powerful with many advanced features. In this post, we will be using SBT to manage the dependency on Akka. Firstly we must specify the following directory structure:&lt;/p&gt;
&lt;pre class=&#34;bash&#34;&gt;&lt;code&gt;.
├── build.sbt
└── src
    └── main
        └── scala

3 directories, 1 file&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The file build.sbt will contain the information required by SBT to download the Akka Stream dependencies. The &lt;code&gt;.scala&lt;/code&gt; source code will live in the &lt;code&gt;scala&lt;/code&gt; directory.&lt;/p&gt;
&lt;div id=&#34;dependencies-in-sbt&#34; class=&#34;section level3&#34;&gt;
&lt;h3&gt;Dependencies in SBT&lt;/h3&gt;
&lt;p&gt;First, we need to to specify some library dependencies in the file &lt;code&gt;build.sbt&lt;/code&gt;:&lt;/p&gt;
&lt;pre class=&#34;scala&#34;&gt;&lt;code&gt;name := &amp;quot;Akka-Stream-Example&amp;quot;
version := &amp;quot;1.0&amp;quot;

scalaVersion := &amp;quot;2.11.8&amp;quot;

libraryDependencies += &amp;quot;com.typesafe.akka&amp;quot; %% &amp;quot;akka-stream&amp;quot; % &amp;quot;2.4.14&amp;quot;&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now, in the terminal, navigate to the root directory of the project and run &lt;code&gt;sbt&lt;/code&gt;. The dependencies will be downloaded automatically, and available to use in any source files.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div id=&#34;source&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Source&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;Source&lt;/code&gt; represents the start of an Akka stream, there are many methods for constructing streams from &lt;code&gt;Source&lt;/code&gt;. For now, we will define a ticking stream of integers and investigate how we can transform and output this stream using &lt;code&gt;Flow&lt;/code&gt;s and &lt;code&gt;Sink&lt;/code&gt;s respectively. Here is a &lt;code&gt;Source&lt;/code&gt; which outputs a steady stream of 1s every second&lt;/p&gt;
&lt;pre class=&#34;scala&#34;&gt;&lt;code&gt;import akka.actor.ActorSystem
import akka.stream.ActorMaterializer
import akka.stream.scaladsl._

object Streaming {
  implicit val system = ActorSystem(&amp;quot;Streaming&amp;quot;)
  implicit val executor = system.dispatcher
  implicit val materializer = ActorMaterializer()

  val in = Source.tick(1.second, 1.second, 1)
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div id=&#34;flow&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Flow&lt;/h2&gt;
&lt;p&gt;A &lt;code&gt;Flow&lt;/code&gt; is a data processing stage. We will define a data flow which takes in an integer, then doubles it.&lt;/p&gt;
&lt;pre class=&#34;scala&#34;&gt;&lt;code&gt;val doubleFlow = Flow[Int].map(a =&amp;gt; a * 2)&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This &lt;code&gt;Flow&lt;/code&gt; is reusable and can be joined on to any stream which emits an &lt;code&gt;Int&lt;/code&gt;. The &lt;code&gt;map&lt;/code&gt; function is an example of a higher-order function; a higher-order function accepts a function as an argument. The &lt;code&gt;map&lt;/code&gt; function here is used to access the value held inside of the &lt;code&gt;Flow&lt;/code&gt;, in this case an &lt;code&gt;Int&lt;/code&gt;. The function passed as the argument to &lt;code&gt;map&lt;/code&gt; is an anonymous (or lambda) function, it says we take the &lt;code&gt;Int&lt;/code&gt; and multiply it by two, a type annotation is not needed on the value &lt;code&gt;a&lt;/code&gt; as the compiler infers the type to be &lt;code&gt;Int&lt;/code&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;sink&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Sink&lt;/h2&gt;
&lt;p&gt;A &lt;code&gt;Sink&lt;/code&gt; is an endpoint to a stream, we can use it to print to the console, write to a database or another external service. However only when the stream is materialized is the side effect in the &lt;code&gt;Sink&lt;/code&gt; performed. Let’s define a simple sink which prints each element out on a new line&lt;/p&gt;
&lt;pre class=&#34;scala&#34;&gt;&lt;code&gt;val out = Sink.foreach(println)&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;div id=&#34;putting-it-all-together&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Putting it all together&lt;/h2&gt;
&lt;p&gt;Now we want to get our stream printing to the console, we must define a main method for the &lt;code&gt;Streaming&lt;/code&gt; object connecting the &lt;code&gt;Source&lt;/code&gt; to the &lt;code&gt;Flow&lt;/code&gt; and finally to the &lt;code&gt;Sink&lt;/code&gt;.&lt;/p&gt;
&lt;pre class=&#34;scala&#34;&gt;&lt;code&gt;import akka.actor.ActorSystem
import akka.stream.ActorMaterializer
import akka.stream.scaladsl.{Sink, Flow, Source}
import scala.concurrent.duration._

object Streaming {
  implicit val system = ActorSystem(&amp;quot;Streaming&amp;quot;)
  implicit val executor = system.dispatcher
  implicit val materializer = ActorMaterializer()

  val in = Source.tick(1.second, 1.second, 1)
  val double_flow = Flow[Int].map(a =&amp;gt; a * 2)
  val print_sink = Sink.foreach(println)

  def main(args: Array[String]) {
      in.
        via(double_flow).
        take(10).
        runWith(print_sink).
        onComplete(_ =&amp;gt; system.terminate)
  }
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;You can now run this code block using by executing &lt;code&gt;sbt run&lt;/code&gt; from the terminal, in the project directory root (where &lt;code&gt;build.sbt&lt;/code&gt; lives). We should get a stream of twos emitting once every second. The function &lt;code&gt;take&lt;/code&gt; will limit the amount of twos printed to the console and once the stream is exhausted the Akka system is shutdown using the function &lt;code&gt;onComplete&lt;/code&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;graph-dsl&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Graph DSL&lt;/h2&gt;
&lt;p&gt;Akka Streaming provides a domain specific language (DSL) to express stream processing pipelines using a graph. Here is another way to define the main method using a &lt;code&gt;RunnableGraph&lt;/code&gt;:&lt;/p&gt;
&lt;pre class=&#34;scala&#34;&gt;&lt;code&gt;val graph = RunnableGraph.fromGraph(GraphDSL.create() { implicit builder =&amp;gt;

  in ~&amp;gt; double_flow ~&amp;gt; Flow[Int].take(10) ~&amp;gt; print_sink

  ClosedShape
})
  
graph.run()&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The graph DSL requires a bit of work, namely defining a runnable graph and specifying that the graph is closed. This is because we can define partial graphs (a graph which isn’t connected to a &lt;code&gt;Source&lt;/code&gt;, &lt;code&gt;Sink&lt;/code&gt; or both) which compose with other graphs, handy if you want to reuse a block of processing.&lt;/p&gt;
&lt;p&gt;In order to specify a partial graph with no connections, we use &lt;code&gt;FlowShape(inlet, outlet)&lt;/code&gt;. Let’s define a partial graph which takes in one stream a integers, splits them on a condition, performs some processing then sends them out:&lt;/p&gt;
&lt;pre class=&#34;scala&#34;&gt;&lt;code&gt;val partial_graph = Flow.fromGraph(GraphDSL.create() { implicit builder =&amp;gt;
    val broadcast = builder.add(Broadcast[Int](2))
    val zip = builder.add(Zip[Int, Int]())

    broadcast.out(0) ~&amp;gt; Flow[Int].filter(_ % 2 == 0) ~&amp;gt; Flow[Int].map(_ / 2) ~&amp;gt; zip.in0
    broadcast.out(1) ~&amp;gt; Flow[Int].filter(_ % 2 != 0) ~&amp;gt; Flow[Int].map(_ * 2) ~&amp;gt; zip.in1

    FlowShape(broadcast.in, zip.out)
  })&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This &lt;code&gt;FlowShape&lt;/code&gt; is expecting a &lt;code&gt;Source&lt;/code&gt; containing integers, in the first line of processing it checks if the items are even, then divides them by two. The second line of processing doubles all the even numbers. The two streams are then recombined using a zip. In order to materialize data through this processing stage, a &lt;code&gt;Source&lt;/code&gt; of integers and a &lt;code&gt;Sink&lt;/code&gt; must be connected.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;merging-a-stream&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Merging a stream&lt;/h2&gt;
&lt;p&gt;If we have two streams containing the same datatype, then we can merge these two streams into one:&lt;/p&gt;
&lt;p&gt;Let’s reuse our stream of ones and merge it into the stream of twos we already have:&lt;/p&gt;
&lt;pre class=&#34;scala&#34;&gt;&lt;code&gt;val merge_graph = RunnableGraph.fromGraph(GraphDSL.create() { implicit builder =&amp;gt;
  val merge = builder.add(Merge[Int](2))
  
  in ~&amp;gt; double_flow ~&amp;gt; merge ~&amp;gt; print_sink
                in ~&amp;gt; merge
  ClosedShape
})&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We add a &lt;code&gt;Merge&lt;/code&gt; to the graph builder, &lt;code&gt;Merge&lt;/code&gt; requires we specify the type of the stream elements we are merging and the number of stream sources we are merging. We then alter the stream processing flow to include a stream of ones and perform the merge.&lt;/p&gt;
&lt;p&gt;In this case, if the stream of ones was publishing at a higher frequency than the other stream, we would have a stream with more ones than twos. ie:&lt;/p&gt;
&lt;p&gt;1 1 1 2 1 1 1 2 …&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;zipping-a-stream&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Zipping a Stream&lt;/h2&gt;
&lt;p&gt;We can zip a stream just as we can zip collections in Scala. This results in a tuple, which can have heterogeneous types. Zip requires that both streams have an element available, so if one stream is publishing at a quicker rate than the others there will be buffering of those elements.&lt;/p&gt;
&lt;p&gt;To illustrate this, we will build a continuous stream of natural numbers using the &lt;code&gt;unfold&lt;/code&gt; function:&lt;/p&gt;
&lt;pre class=&#34;scala&#34;&gt;&lt;code&gt;val naturalNumbers = Source.unfold(1)(a =&amp;gt; Some(a + 1, a))&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;unfold&lt;/code&gt; is the dual of &lt;code&gt;fold&lt;/code&gt; and is an &lt;a href=&#34;https://en.wikipedia.org/wiki/Anamorphism&#34;&gt;Anamorphism&lt;/a&gt;. &lt;code&gt;unfold&lt;/code&gt; starts with a &lt;code&gt;seed&lt;/code&gt; value and applies a function to produce the next value in the stream, the result of this function evaluation is sent to the next evaluation and so on. Using &lt;code&gt;unfold&lt;/code&gt; is a simple way to define a stream which depends on the previous value.&lt;/p&gt;
&lt;p&gt;Now if we zip together a continuous source of ones which publishes every ten seconds, &lt;code&gt;Zip&lt;/code&gt; will wait for both streams to have an element before publishing the tuple of both streams, guaranteeing order.&lt;/p&gt;
&lt;pre class=&#34;scala&#34;&gt;&lt;code&gt;val in = Source.tick(1.second, 10.seconds, 1)

val zipStream = RunnableGraph.fromGraph(FlowGraph.create() { implicit builder =&amp;amp;amp;amp;gt;
    val zip = builder.add(Zip[Int, Int])
    naturalNumbers ~&amp;gt; zip.in0
    in ~&amp;gt; zip.in1
    zip.out ~&amp;gt; out

    ClosedShape
  })

  def main(args: Array[String]): Unit = {
    zipStream.run(materializer)
  }&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The output from this stream is: (1,1) (2,1) (3,1) …&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;summary&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Summary&lt;/h2&gt;
&lt;p&gt;We have covered a few ways to express simple streams using Akka Streaming. The real power of Akka streaming is when it is combined with file or connection handling. Streaming libraries can be used to process extremely large, or unbounded, data files using a bounded amount of computational power. This is useful when dealing with infinite sources of data, such as streaming data from Twitter.&lt;/p&gt;
&lt;/div&gt;



&lt;!-- BLOGDOWN-HEAD






/BLOGDOWN-HEAD --&gt;
</description>
    </item>
    
    <item>
      <title>Using Monads for Handling Failures and Exceptions</title>
      <link>/post/FailureInFunctionalProgramming/</link>
      <pubDate>Mon, 04 Jan 2016 12:13:14 -0500</pubDate>
      
      <guid>/post/FailureInFunctionalProgramming/</guid>
      <description>&lt;!-- BLOGDOWN-BODY-BEFORE

/BLOGDOWN-BODY-BEFORE --&gt;

&lt;p&gt;In this post I will give a practical introduction to some useful structures for handling failure in functional programming.&lt;/p&gt;
&lt;div id=&#34;referential-transparency&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Referential Transparency&lt;/h2&gt;
&lt;p&gt;One of the most important properties of functional programming is referential transparency and programming with pure functions. This means we can substitute a pure function with its result, for intance if we have the function &lt;code&gt;def f = 1 + 2&lt;/code&gt;, we can replace every occurence of &lt;code&gt;f&lt;/code&gt; with &lt;code&gt;3&lt;/code&gt; and the final evaluation will remain unchanged&lt;/p&gt;
&lt;p&gt;This simple idea can lead to difficulties when considering functions which involve side effects, such as reading from external sources or generating random numbers. One example of a side effect is an exception, an imperative programmer might write a function to calculate a square root as:&lt;/p&gt;
&lt;pre class=&#34;scala&#34;&gt;&lt;code&gt;def unsafe_sqrt(a: Double): Double = {
  if (a &amp;gt; 0) math.sqrt(a)
  else throw new Exception(&amp;quot;Can&amp;#39;t calculate square root of negative number&amp;quot;)
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This compiles fine, however if we wrote this function for an end user and they didn’t look at the implementation they might not know the function can possibly return an exception.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;try&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Try&lt;/h2&gt;
&lt;p&gt;In order to make it clear that a function can fail, we can return a &lt;code&gt;Try&lt;/code&gt;:&lt;/p&gt;
&lt;pre class=&#34;scala&#34;&gt;&lt;code&gt;def try_sqrt(a: Double): Try[Double] = {
  if (a &amp;gt; 0) Success(math.sqrt(a))
  else Failure(throw new Exception(&amp;quot;Can&amp;#39;t calculate square root of negative number&amp;quot;))
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now, if someone were to use this function they would be forced to deal with the &lt;code&gt;Try&lt;/code&gt; return type and understand that the function can return an exception. Try is actually an algebraic datatype (ADT), an illustrative implementation is:&lt;/p&gt;
&lt;pre class=&#34;scala&#34;&gt;&lt;code&gt;sealed trait Try[+A]
case class Success[+A](a: A) extends Try[A]
case class Failure[+A](exception: Throwable) extends Try[A]&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This means that a &lt;code&gt;Try&lt;/code&gt; can either be a &lt;code&gt;Success&lt;/code&gt; or &lt;code&gt;Failure&lt;/code&gt;. Learn more about &lt;code&gt;Try&lt;/code&gt; in Daniel Westheide’s excellent &lt;a href=&#34;http://danielwestheide.com/blog/2012/12/26/the-neophytes-guide-to-scala-part-6-error-handling-with-try.html&#34;&gt;Neophyte’s Guide to Scala&lt;/a&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;option&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Option&lt;/h2&gt;
&lt;p&gt;Another simple structure to represent computations which may fail is &lt;code&gt;Option&lt;/code&gt;, this is an algebraic datatype:&lt;/p&gt;
&lt;pre class=&#34;scala&#34;&gt;&lt;code&gt;sealed trait Option[+A]
case class Some[+A](a: A) extends Option[A]
case class None extends Option[Nothing]&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;In this case, option can either contain a value using the constructor &lt;code&gt;Some&lt;/code&gt;, or can represent the absense of a value using &lt;code&gt;None&lt;/code&gt;. This provides less information on failure that &lt;code&gt;Try&lt;/code&gt;, but nevertheless is sometimes useful. We can re-write the &lt;code&gt;sqrt&lt;/code&gt; function to return an optional value&lt;/p&gt;
&lt;pre class=&#34;scala&#34;&gt;&lt;code&gt;def option_sqrt(a: Double): Option[Double] = {
  if (a &amp;gt; 0) Some(math.sqrt(a))
  else None
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now, when provide an incorrect argument to the function, we get &lt;code&gt;None&lt;/code&gt; as the result.&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;chaining-computations&#34; class=&#34;section level1&#34;&gt;
&lt;h1&gt;Chaining Computations&lt;/h1&gt;
&lt;p&gt;In real world functional codebases we compose programs from many small functions. Let’s consider the problem of how to apply &lt;code&gt;def sqrt(a: Double): Option[Double]&lt;/code&gt; twice. A naive attempt would be to simply compose the functions as we would for the Scala math library:&lt;/p&gt;
&lt;pre class=&#34;scala&#34;&gt;&lt;code&gt;def sqrt_twice = unsafe_sqrt _ compose unsafe_sqrt _&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The &lt;code&gt;_&lt;/code&gt; represents partial application of &lt;code&gt;unsafe_sqrt&lt;/code&gt;, if we try to compose the &lt;code&gt;option_sqrt&lt;/code&gt; function as in this example we will get a type mismatch. One application of &lt;code&gt;option_sqrt&lt;/code&gt; returns a typle &lt;code&gt;Option[Double]&lt;/code&gt;, but we need the type &lt;code&gt;Double&lt;/code&gt;. Luckily &lt;code&gt;Option&lt;/code&gt; has a function defined on it for composing operations like this:&lt;/p&gt;
&lt;pre class=&#34;scala&#34;&gt;&lt;code&gt;def flatMap[A, B](a: Option[A])(f: A =&amp;gt; Option[B]): Option[B]&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We can now use &lt;code&gt;flatMap&lt;/code&gt; to compose &lt;code&gt;option_sqrt&lt;/code&gt;:&lt;/p&gt;
&lt;pre class=&#34;scala&#34;&gt;&lt;code&gt;def sqrt_twice_option(x: Double): Option[Double] = 
  option_sqrt(x) flatMap option_sqrt&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now we can calculate &lt;code&gt;sqrt_twice_option(81) = Some(3.0)&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;We can compose &lt;code&gt;try_sqrt&lt;/code&gt; in the same way:&lt;/p&gt;
&lt;pre class=&#34;scala&#34;&gt;&lt;code&gt;def sqrt_twice_try(x: Double): Try[Double] = 
  try_sqrt(81) flatMap try_sqrt&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now, what if we want to compose &lt;code&gt;option_sqrt&lt;/code&gt; and &lt;code&gt;try_sqrt&lt;/code&gt;. This is not an easy problem in general, however the Scala standard library implements a &lt;code&gt;toOption&lt;/code&gt; method on &lt;code&gt;Try&lt;/code&gt; values. Hence we can just convert the output of &lt;code&gt;try_sqrt&lt;/code&gt; to an &lt;code&gt;Option&lt;/code&gt;, however we lose the text from the exception upon failure, which could illuminating in the event of a failure. Let’s consider a more general way to compose the two.&lt;/p&gt;
&lt;div id=&#34;nested-maps&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Nested Maps&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;Option&lt;/code&gt; and &lt;code&gt;Try&lt;/code&gt; are both monads (strictly &lt;code&gt;Try&lt;/code&gt; is &lt;a href=&#34;https://issues.scala-lang.org/browse/SI-6284&#34;&gt;not a proper monad&lt;/a&gt;), which means they are equipped with two methods which satisfy the monad laws. The two methods defined for all monads are:&lt;/p&gt;
&lt;pre class=&#34;scala&#34;&gt;&lt;code&gt;trait Monad[A, M[_]] {
  def flatMap[B](f: A =&amp;gt; M[B]): M[B]
  def pure(a: A): M[A]
}&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We can define all the functions on &lt;code&gt;Try&lt;/code&gt; and &lt;code&gt;Option&lt;/code&gt; using these two functions, for instance &lt;code&gt;map&lt;/code&gt;:&lt;/p&gt;
&lt;pre class=&#34;scala&#34;&gt;&lt;code&gt;def map[B](f: A =&amp;gt; B): M[B] = this.flatMap(a =&amp;gt; pure(f(a)))&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Now, we can use the &lt;code&gt;map&lt;/code&gt; function to compose &lt;code&gt;option_sqrt&lt;/code&gt; and &lt;code&gt;try_sqrt&lt;/code&gt;:&lt;/p&gt;
&lt;pre class=&#34;scala&#34;&gt;&lt;code&gt;def sqrt_twice(a: Double): Try[Option[Double]] = try_sqrt(a) map option_sqrt&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;However, what if we want to apply another function to a value returned by this function:&lt;/p&gt;
&lt;pre class=&#34;scala&#34;&gt;&lt;code&gt;def f(a: Double) = a + 1
sqrt_twice(81) map (_.map(f))
// Success(Some(4.0))&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We get the correct value, but we have to apply &lt;code&gt;map&lt;/code&gt; twice, this seems cumbersome. There is a better way!&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&#34;monad-transformers&#34; class=&#34;section level2&#34;&gt;
&lt;h2&gt;Monad Transformers&lt;/h2&gt;
&lt;p&gt;The functional programming library &lt;a href=&#34;http://typelevel.org/cats/&#34;&gt;cats&lt;/a&gt;, short for category, has some built in types for dealing with nesting in a more elegent way. The type &lt;code&gt;OptionT[F[_], A]&lt;/code&gt; can be used instead of &lt;code&gt;F[Option[A]]&lt;/code&gt;, our &lt;code&gt;F[_]&lt;/code&gt; type in this case is &lt;code&gt;Try[A]&lt;/code&gt;&lt;/p&gt;
&lt;pre class=&#34;scala&#34;&gt;&lt;code&gt;import cats.implicits._
import cats.data.OptionT

def sqrt_twice_trans(a: Double): OptionT[Try, Double] = 
  OptionT.fromOption[Try](option_sqrt(a)) flatMap (b =&amp;gt; OptionT.liftF(try_sqrt(b))&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;OptionT&lt;/code&gt; provides the function &lt;code&gt;fromOption&lt;/code&gt; to transform the result of the &lt;code&gt;option_sqrt&lt;/code&gt; function into the &lt;code&gt;OptionT&lt;/code&gt; monad. The function &lt;code&gt;liftF&lt;/code&gt; is used to lift any monad, in this case &lt;code&gt;Try&lt;/code&gt; into the &lt;code&gt;OptionT&lt;/code&gt; monad. This compiles and we if we now try to apply the function &lt;code&gt;def f(a: Double) = a + 1&lt;/code&gt; to the result of this function we only need a single call to &lt;code&gt;map&lt;/code&gt;. This is because &lt;code&gt;OptionT&lt;/code&gt; is also a monad:&lt;/p&gt;
&lt;pre class=&#34;scala&#34;&gt;&lt;code&gt;sqrt_twice_trans(81) map f
// OptionT(Success(Some(4.0)))&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;This may seem like quite a lot of effort to remove a call to map, but removing unecessary duplication can help with readability of code, and enable bugs to be spotted earlier.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;



&lt;!-- BLOGDOWN-HEAD






/BLOGDOWN-HEAD --&gt;
</description>
    </item>
    
  </channel>
</rss>